/**
 * This file serves simply as a wapper for the header generated by Bison.
 * This way, if the name of the generated header changes, we only need to change 
 * it in one place.
 */

#pragma once

#include <optional>

#include "shell/parser/parser.y.hpp"
#include "shell/ast/ast.hpp"

namespace shell {

    /**
     * @brief Parser for the shell language. Reads input from a stream and returns a parsed abstract syntax tree.
     */
    class Parser : public yyBisonParser
    {
    public:
        /**
         * @brief Constructs a new parser using the passed lexer
         */
        Parser(shell::Lexer& _lexer)
        : yyBisonParser(_lexer, *this)
        {

        }

        /**
         * @brief Parses the next statement in the input stream and then returns the result as an AstNode.
         * 
         * @remark This function is intended for implementing an interactive shell where input is executed one statement at a time.
         * 
         * @return An std::optional containing an AstNode if the parse was successful, or std::nullopt otherwise. 
         */
        std::optional<AstNode> parseNextStatement();

        /**
         * @brief Parses the input stream until the end of the file. 
         * 
         * @remark This function is intended for implementing the execution of an entire script file or for files piped through the command line.
         * 
         * @return An std::optional containing an AstNode if the parse was successful, or std::nullopt otherwise. 
         */
        std::optional<AstNode> parseFile();
        
        friend class yyBisonParser;

    protected:
        bool                    stopAfterStatement = false;
        std::optional<AstNode>  result = std::nullopt;
    };

} // namespace shell
